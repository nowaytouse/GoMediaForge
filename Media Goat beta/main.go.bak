// Filename: main.go
package main

import (
	"bufio"
	"bytes"
	"crypto/sha1"
	"encoding/hex"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/fatih/color"
)

// --- Script Configuration & Globals ---
const Version = "12.3.0-GO-EDITION"

type Config struct {
	Mode          string
	TargetDir     string
	ConcurrentJobs int
	EnableBackups bool
	SortOrder     string
}

// Global state and counters
var (
	logFile       *os.File
	reportFile    string
	resultsDir    string
	tempDir       string
	runStarted    time.Time
	totalFiles    int
	processedCount int
	successCount  int
	failCount     int
	skipCount     int
	resumedCount  int
	totalSaved    int64

	// Terminal Colors
	bold      = color.New(color.Bold).SprintFunc()
	cyan      = color.New(color.FgCyan).SprintFunc()
	green     = color.New(color.FgGreen).SprintFunc()
	yellow    = color.New(color.FgYellow).SprintFunc()
	red       = color.New(color.FgRed).SprintFunc()
	violet    = color.New(color.FgHiMagenta).SprintFunc()
	subtle    = color.New(color.Faint).SprintFunc()
)

// --- Logging ---
func initLogging(cfg Config) {
	logDir := cfg.TargetDir
	timestamp := time.Now().Format("20060102_150405")
	logFileName := filepath.Join(logDir, fmt.Sprintf("%s_conversion_%s.txt", cfg.Mode, timestamp))
	reportFile = filepath.Join(logDir, fmt.Sprintf("%s_conversion_report_%s.txt", cfg.Mode, timestamp))

	var err error
	logFile, err = os.OpenFile(logFileName, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalf("无法创建日志文件: %v", err)
	}

	log.SetOutput(logFile)
	log.SetFlags(log.Ldate | log.Ltime)

	// Log header
	header := fmt.Sprintf(`📜 媒体转换日志 - %s
=================================================
  - Go 版本: %s
  - 模式: %s
  - 目标: %s
  - 并发: %d
  - 备份: %t
=================================================`,
		time.Now().Format(time.RFC1123), Version, cfg.Mode, cfg.TargetDir, cfg.ConcurrentJobs, cfg.EnableBackups)
	log.Println(header)
	fmt.Fprintln(logFile, header) // Also write directly to file to bypass log prefix
}

func logMessage(level, message string) {
	log.Printf("[%s] %s\n", level, message)
}

// --- Core Utilities ---

// execute command and return output, optionally logging errors
func runCmd(name string, args ...string) (string, error) {
	cmd := exec.Command(name, args...)
	var out, errOut bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &errOut

	err := cmd.Run()
	if err != nil {
		errMsg := fmt.Sprintf("命令执行失败: %s %s. 错误: %v. Stderr: %s", name, strings.Join(args, " "), err, errOut.String())
		logMessage("ERROR", errMsg)
		return "", fmt.Errorf(errMsg)
	}
	return strings.TrimSpace(out.String()), nil
}

func getFileSize(path string) int64 {
	fi, err := os.Stat(path)
	if err != nil {
		return 0
	}
	return fi.Size()
}

func getMimeType(file string) string {
	// `file` command is more reliable on Linux/macOS
	if runtime.GOOS != "windows" {
		out, err := runCmd("file", "--mime-type", "-b", file)
		if err == nil && !strings.Contains(out, "application/octet-stream") {
			return out
		}
	}
	// Fallback to extension for octet-stream or Windows
	ext := strings.ToLower(filepath.Ext(file))
	switch ext {
	case ".webm", ".mp4", ".avi", ".mov", ".mkv", ".flv", ".wmv", ".m4v":
		return "video/" + strings.TrimPrefix(ext, ".")
	case ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".webp", ".heic", ".heif", ".jxl", ".avif":
		return "image/" + strings.TrimPrefix(ext, ".")
	default:
		return "unknown"
	}
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

func createBackup(file, backupDir string, enabled bool) bool {
	if !enabled {
		return true // Pretend success if disabled
	}
	if err := os.MkdirAll(backupDir, 0755); err != nil {
		logMessage("ERROR", fmt.Sprintf("无法创建备份目录 %s: %v", backupDir, err))
		return false
	}
	
	base := filepath.Base(file)
	ext := filepath.Ext(base)
	name := strings.TrimSuffix(base, ext)
	backupPath := filepath.Join(backupDir, fmt.Sprintf("%s_%d.bak%s", name, time.Now().Unix(), ext))

	sourceFile, err := os.Open(file)
	if err != nil {
		logMessage("ERROR", fmt.Sprintf("无法打开源文件进行备份 %s: %v", file, err))
		return false
	}
	defer sourceFile.Close()

	destFile, err := os.Create(backupPath)
	if err != nil {
		logMessage("ERROR", fmt.Sprintf("无法创建备份文件 %s: %v", backupPath, err))
		return false
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, sourceFile)
	if err != nil {
		logMessage("ERROR", fmt.Sprintf("备份文件失败 %s: %v", file, err))
		os.Remove(backupPath)
		return false
	}
	logMessage("INFO", fmt.Sprintf("已创建备份: %s", backupPath))
	return true
}

func preserveMetadata(src, dst string) {
	// Preserve file modification time
	srcInfo, err := os.Stat(src)
	if err == nil {
		os.Chtimes(dst, srcInfo.ModTime(), srcInfo.ModTime())
	}
	
	// Preserve EXIF data using exiftool
	_, err = runCmd("exiftool", "-TagsFromFile", src, "-all:all", "--icc_profile", "-overwrite_original", "-preserve", dst)
	if err != nil {
		logMessage("WARN", fmt.Sprintf("元数据迁移可能不完整: %s -> %s", filepath.Base(src), filepath.Base(dst)))
	}
}

func getResultFilePath(filePath string) string {
	hash := sha1.Sum([]byte(filePath))
	return filepath.Join(resultsDir, hex.EncodeToString(hash[:]))
}

// --- Media Analysis ---
func isAnimated(file string) bool {
	mime := getMimeType(file)
	if !strings.Contains(mime, "gif") && !strings.Contains(mime, "webp") && !strings.Contains(mime, "avif") {
		return false
	}
	// ffprobe is the most reliable way to check frame count
	out, err := runCmd("ffprobe", "-v", "quiet", "-select_streams", "v:0", "-show_entries", "stream=nb_frames", "-of", "csv=p=0", file)
	if err != nil {
		return false // Assume not animated on error
	}
	frames, _ := strconv.Atoi(out)
	return frames > 1
}

// A simple heuristic for what to skip
func shouldSkipFile(file string, mode string) (bool, string) {
	base := filepath.Base(file)
	mime := getMimeType(file)

	if !strings.HasPrefix(mime, "image/") && !strings.HasPrefix(mime, "video/") {
		return true, fmt.Sprintf("⏭️ 跳过不支持的MIME类型: %s (%s)", base, mime)
	}

	targetExt := ""
	if strings.HasPrefix(mime, "image/") {
		if mode == "quality" {
			targetExt = ".jxl"
		} else {
			targetExt = ".avif"
		}
	} else { // video
		targetExt = ".mov"
	}

	if strings.HasSuffix(strings.ToLower(file), targetExt) {
		return true, fmt.Sprintf("文件已是目标格式: %s", base)
	}
	
	targetFilename := strings.TrimSuffix(file, filepath.Ext(file)) + targetExt
	if fileExists(targetFilename) {
		return true, fmt.Sprintf("⏭️ 跳过，目标文件已存在: %s", filepath.Base(targetFilename))
	}

	return false, ""
}


// --- Conversion Logic ---

// Represents a conversion attempt
type conversionResult struct {
	FilePath     string
	Tag          string
	Decision     string
	OriginalSize int64
	NewSize      int64
	Error        error
}

// This is the core worker function, equivalent to `process_file` in bash
func processFile(filePath, mode string, cfg Config) conversionResult {
	logMessage("INFO", fmt.Sprintf("开始处理: %s (模式: %s)", filepath.Base(filePath), mode))
	
	result := conversionResult{FilePath: filePath, OriginalSize: getFileSize(filePath)}

	if skip, reason := shouldSkipFile(filePath, mode); skip {
		logMessage("INFO", reason)
		result.Decision = "SKIP"
		return result
	}

	// Create a temporary directory for this file's operations
	fileTempDir, err := os.MkdirTemp(tempDir, "conv_*")
	if err != nil {
		result.Error = fmt.Errorf("无法创建临时目录: %v", err)
		return result
	}
	defer os.RemoveAll(fileTempDir)
	
	mime := getMimeType(filePath)
	var tempOutPath, tag, decision string

	if strings.HasPrefix(mime, "image/") {
		tempOutPath, tag, decision, err = processImage(filePath, fileTempDir, result.OriginalSize, mode)
	} else if strings.HasPrefix(mime, "video/") {
		tempOutPath, tag, decision, err = processVideo(filePath, fileTempDir, mode)
	} else {
		result.Decision = "SKIP"
		logMessage("INFO", fmt.Sprintf("跳过未知类型文件: %s", filepath.Base(filePath)))
		return result
	}

	if err != nil {
		result.Error = err
		logMessage("ERROR", fmt.Sprintf("核心转换过程失败: %s. 原因: %v", filepath.Base(filePath), err))
		return result
	}

	result.NewSize = getFileSize(tempOutPath)
	result.Tag = tag
	result.Decision = decision

	if result.NewSize <= 0 {
		result.Error = fmt.Errorf("转换后文件大小无效")
		return result
	}

	// Decide whether to replace the original
	shouldReplace := false
	if mode == "quality" {
		shouldReplace = true // In quality mode, we replace even if larger (e.g., PNG to lossless JXL)
	} else { // efficiency mode
		if result.NewSize < result.OriginalSize {
			shouldReplace = true
		}
	}
	
	if shouldReplace {
		backupDir := filepath.Join(cfg.TargetDir, ".backups")
		if !createBackup(filePath, backupDir, cfg.EnableBackups) {
			result.Error = fmt.Errorf("创建备份失败，中止替换")
			return result
		}

		preserveMetadata(filePath, tempOutPath)
		
		targetPath := strings.TrimSuffix(filePath, filepath.Ext(filePath)) + filepath.Ext(tempOutPath)
		
		if err := os.Rename(tempOutPath, targetPath); err != nil {
			result.Error = fmt.Errorf("无法移动转换后的文件: %v", err)
			return result
		}
		
		// If the original file extension is different, remove it
		if strings.ToLower(filePath) != strings.ToLower(targetPath) {
			os.Remove(filePath)
		}

		logMessage("SUCCESS", fmt.Sprintf("%s | %s -> %s | %s", filepath.Base(targetPath), formatBytes(result.OriginalSize), formatBytes(result.NewSize), tag))
	} else {
		result.Decision = "SKIP_LARGER"
		logMessage("WARN", fmt.Sprintf("转换后文件增大，不替换: %s (%s -> %s)", filepath.Base(filePath), formatBytes(result.OriginalSize), formatBytes(result.NewSize)))
	}

	return result
}

func processImage(input, tempDir string, originalSize int64, mode string) (string, string, string, error) {
	isAnim := isAnimated(input)
	
	// In quality mode, we go straight for lossless
	if mode == "quality" {
		ext := "jxl"
		if isAnim {
			ext = "avif"
		}
		losslessPath := filepath.Join(tempDir, "lossless."+ext)
		tag, err := generateLosslessImage(input, losslessPath, isAnim)
		if err != nil {
			return "", "", "", err
		}
		return losslessPath, tag, "QUALITY_LOSSLESS", nil
	}

	// Efficiency mode: smart analysis
	var wg sync.WaitGroup
	var losslessPath, lossyPath string
	var losslessTag, lossyTag string
	var losslessErr, lossyErr error

	wg.Add(2)

	// Attempt lossless conversion in parallel
	go func() {
		defer wg.Done()
		ext := "jxl"
		if isAnim {
			ext = "avif"
		}
		path := filepath.Join(tempDir, "lossless."+ext)
		losslessTag, losslessErr = generateLosslessImage(input, path, isAnim)
		if losslessErr == nil {
			losslessPath = path
		}
	}()

	// Attempt lossy conversion in parallel
	go func() {
		defer wg.Done()
		path := filepath.Join(tempDir, "lossy.avif")
		lossyTag, lossyErr = generateLossyImage(input, path, isAnim, 80) // Start with quality 80
		if lossyErr == nil {
			lossyPath = path
		}
	}()
	
	wg.Wait()

	losslessSize := getFileSize(losslessPath)
	lossySize := getFileSize(lossyPath)
	
	// Smart decision logic
	if losslessSize > 0 && losslessSize < lossySize && float64(losslessSize) < float64(originalSize)*0.8 {
		logMessage("INFO", fmt.Sprintf("智能决策: 无损 (%s) 优于有损 (%s) for %s", formatBytes(losslessSize), formatBytes(lossySize), filepath.Base(input)))
		os.Remove(lossyPath)
		return losslessPath, losslessTag, "SMART_LOSSLESS", nil
	}

	if lossySize > 0 && float64(lossySize) < float64(originalSize)*0.9 {
		logMessage("INFO", fmt.Sprintf("智能决策: 有损 (%s) 足够好 for %s", formatBytes(lossySize), filepath.Base(input)))
		os.Remove(losslessPath)
		return lossyPath, lossyTag, "SMART_LOSSY", nil
	}
	
	// If lossy is not good enough, and lossless is not better, maybe original is best.
	// But we must return one if successful. Prioritize the smaller one.
	if lossySize > 0 && (losslessSize == 0 || lossySize < losslessSize) {
		os.Remove(losslessPath)
		return lossyPath, lossyTag, "LOSSY_DEFAULT", nil
	}
	if losslessSize > 0 {
		os.Remove(lossyPath)
		return losslessPath, losslessTag, "LOSSLESS_DEFAULT", nil
	}

	return "", "", "", fmt.Errorf("所有图片转换尝试均失败")
}

func generateLosslessImage(input, output string, isAnim bool) (string, error) {
	if isAnim { // Animated -> Lossless AVIF
		_, err := runCmd("ffmpeg", "-hide_banner", "-v", "error", "-y", "-i", input, "-c:v", "libsvtav1", "-qp", "0", "-preset", "8", "-pix_fmt", "yuv420p", "-f", "avif", output)
		return "AVIF-Lossless", err
	}
	// Static -> Lossless JXL
	_, err := runCmd("cjxl", input, output, "-d", "0", "-e", "9")
	if err != nil {
		// Fallback to ImageMagick if cjxl fails
		_, err = runCmd("magick", input, "-quality", "100", output)
		return "JXL-Lossless(fallback)", err
	}
	return "JXL-Lossless", err
}

func generateLossyImage(input, output string, isAnim bool, quality int) (string, error) {
	qStr := strconv.Itoa(quality)
	if isAnim { // Animated -> AVIF with CRF
		// FFMPEG uses CRF for AV1, let's map quality to a reasonable CRF (30-50 range is good)
		crf := 30 + (100-quality)/4
		_, err := runCmd("ffmpeg", "-hide_banner", "-v", "error", "-y", "-i", input, "-c:v", "libsvtav1", "-crf", strconv.Itoa(crf), "-preset", "7", "-pix_fmt", "yuv420p", "-f", "avif", output)
		return "AVIF-Anim-CRF" + strconv.Itoa(crf), err
	}
	// Static -> AVIF with quality
	_, err := runCmd("magick", input, "-quality", qStr, output)
	return "AVIF-Q" + qStr, err
}


func processVideo(input, tempDir string, mode string) (string, string, string, error) {
    base := filepath.Base(input)
    tempOut := filepath.Join(tempDir, strings.TrimSuffix(base, filepath.Ext(base)) + ".mov")

    var attempts []struct{
        name string
        args []string
        tag  string
    }

    if mode == "quality" {
        attempts = []struct{name string; args []string; tag string}{
            {"HEVC Lossless", []string{"-c:v", "libx265", "-x265-params", "lossless=1", "-c:a", "aac", "-b:a", "192k"}, "HEVC-Quality"},
            {"AV1 Lossless", []string{"-c:v", "libsvtav1", "-qp", "0", "-preset", "8", "-c:a", "copy"}, "AV1-Lossless-Fallback"},
            {"Remux", []string{"-c", "copy", "-map", "0"}, "REMUX-Fallback"},
        }
    } else { // efficiency
        attempts = []struct{name string; args []string; tag string}{
            {"HEVC Lossy", []string{"-c:v", "libx265", "-crf", "28", "-preset", "medium", "-c:a", "aac", "-b:a", "128k"}, "HEVC-CRF28"},
            {"AV1 Lossy", []string{"-c:v", "libsvtav1", "-crf", "35", "-preset", "7", "-c:a", "aac", "-b:a", "128k"}, "AV1-CRF35-Fallback"},
            {"Remux", []string{"-c", "copy", "-map", "0"}, "REMUX-Fallback"},
        }
    }

    commonArgs := []string{"-hide_banner", "-v", "error", "-y", "-i", input}
    finalArgs := []string{"-movflags", "+faststart", "-avoid_negative_ts", "make_zero", tempOut}

    for _, attempt := range attempts {
        logMessage("INFO", fmt.Sprintf("视频尝试: [%s] for %s", attempt.name, base))
        args := append(commonArgs, attempt.args...)
        args = append(args, finalArgs...)
        _, err := runCmd("ffmpeg", args...)
        if err == nil && getFileSize(tempOut) > 0 {
            logMessage("INFO", fmt.Sprintf("视频成功: [%s]", attempt.name))
            return tempOut, attempt.tag, "VIDEO_CONVERTED", nil
        }
        logMessage("WARN", fmt.Sprintf("视频失败: [%s]. Error: %v", attempt.name, err))
    }

    return "", "", "", fmt.Errorf("所有视频转换尝试均失败: %s", base)
}


// --- Main Logic & UI ---

func formatBytes(b int64) string {
	const unit = 1024
	if b < unit {
		return fmt.Sprintf("%d B", b)
	}
	div, exp := int64(unit), 0
	for n := b / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %ciB", float64(b)/float64(div), "KMGTPE"[exp])
}

type FileTask struct {
    Path string
    Size int64
    // for auto mode
    Mode string
}

func main() {
	var cfg Config
	flag.StringVar(&cfg.Mode, "mode", "", "转换模式: 'quality', 'efficiency', or 'auto'")
	flag.StringVar(&cfg.TargetDir, "dir", "", "目标目录路径")
	flag.IntVar(&cfg.ConcurrentJobs, "jobs", 0, "并发任务数 (0 for auto)")
	flag.BoolVar(&cfg.EnableBackups, "no-backup", true, "禁用备份 (设置为false来禁用)")
	flag.StringVar(&cfg.SortOrder, "sort-by", "size", "处理顺序: 'size' or 'quality'")
	flag.Parse()

	// Invert -no-backup logic
	cfg.EnableBackups = flag.Lookup("no-backup").Value.String() != "true" == !cfg.EnableBackups


	if cfg.TargetDir == "" || cfg.Mode == "" {
		interactiveSetup(&cfg)
	}
	
	if err := validateConfig(cfg); err != nil {
		fmt.Println(red("错误: " + err.Error()))
		os.Exit(1)
	}

	if cfg.ConcurrentJobs == 0 {
		cfg.ConcurrentJobs = int(float64(runtime.NumCPU()) * 0.75)
		if cfg.ConcurrentJobs < 1 {
			cfg.ConcurrentJobs = 1
		}
	}
	
	showBanner()
	fmt.Printf("  %-10s %s\n", "📁 目标:", cyan(cfg.TargetDir))
	fmt.Printf("  %-10s %s\n", "🚀 模式:", cyan(cfg.Mode))
	fmt.Printf("  %-10s %s\n", "⚡ 并发:", cyan(strconv.Itoa(cfg.ConcurrentJobs)))
	fmt.Printf("  %-10s %s\n", "🛡️ 备份:", cyan(fmt.Sprintf("%t", cfg.EnableBackups)))
	fmt.Println(subtle("------------------------"))

	var err error
	tempDir, err = os.MkdirTemp("", "media_converter_go")
	if err != nil {
		log.Fatalf("无法创建主临时目录: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	resultsDir = filepath.Join(cfg.TargetDir, ".media_conversion_results")
	os.MkdirAll(resultsDir, 0755)

	initLogging(cfg)
	defer logFile.Close()

	runStarted = time.Now()
	
	fmt.Println(bold("🔎 [1/3] 扫描媒体文件并建立索引..."))
	tasks, err := findFiles(cfg)
	if err != nil {
		fmt.Println(red("错误: " + err.Error()))
		os.Exit(1)
	}

	totalFiles = len(tasks)
	if totalFiles == 0 {
		fmt.Println(yellow("⚠️ 未发现需要处理的媒体文件。"))
		return
	}
	fmt.Printf("  ✨ 发现 %s 个待处理文件 (%s 个文件已跳过)\n", violet(strconv.Itoa(totalFiles)), violet(strconv.Itoa(resumedCount)))

	fmt.Printf(bold("⚙️ [2/3] 开始转换 (并发数: %s)...\n"), cyan(cfg.ConcurrentJobs))
	
	// Worker Pool setup
	jobs := make(chan FileTask, totalFiles)
	results := make(chan conversionResult, totalFiles)
	
	var wg sync.WaitGroup
	for i := 0; i < cfg.ConcurrentJobs; i++ {
		wg.Add(1)
		go worker(&wg, jobs, results, cfg)
	}
	
	for _, task := range tasks {
		jobs <- task
	}
	close(jobs)

	// Progress bar goroutine
	progressDone := make(chan bool)
	go func() {
		for processedCount < totalFiles {
			showProgress(processedCount, totalFiles, "转换中")
			time.Sleep(200 * time.Millisecond)
		}
		showProgress(totalFiles, totalFiles, "完成")
		progressDone <- true
	}()
	
	// Wait for all workers to finish
	wg.Wait()
	close(results)
	<-progressDone

	fmt.Printf("\n"+bold("📊 [3/3] 正在汇总结果并生成报告...\n"))

	var finalResults []conversionResult
	for res := range results {
		processedCount++
		if res.Error != nil {
			failCount++
		} else if res.Decision == "SKIP" || res.Decision == "SKIP_LARGER" {
			skipCount++
		} else {
			successCount++
			totalSaved += (res.OriginalSize - res.NewSize)
		}
		finalResults = append(finalResults, res)
		// Write result file for resuming
		resultFilePath := getResultFilePath(res.FilePath)
		statusLine := fmt.Sprintf("%s|%s|%d|%d", res.Decision, res.Tag, res.OriginalSize, res.NewSize)
		os.WriteFile(resultFilePath, []byte(statusLine), 0644)
	}

	generateReport(cfg, finalResults)
}

func worker(wg *sync.WaitGroup, jobs <-chan FileTask, results chan<- conversionResult, cfg Config) {
	defer wg.Done()
	for task := range jobs {
		mode := cfg.Mode
		if task.Mode != "" { // for auto mode
			mode = task.Mode
		}
		results <- processFile(task.Path, mode, cfg)
	}
}


func findFiles(cfg Config) ([]FileTask, error) {
	var tasks []FileTask
	err := filepath.Walk(cfg.TargetDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		// Skip directories and our own special dirs
		if info.IsDir() {
			if info.Name() == ".backups" || info.Name() == ".media_conversion_results" {
				return filepath.SkipDir
			}
			return nil
		}
		
		// Check if already processed
		resultFile := getResultFilePath(path)
		if fileExists(resultFile) {
			resumedCount++
			return nil
		}
		
		tasks = append(tasks, FileTask{Path: path, Size: info.Size()})
		return nil
	})

	if cfg.SortOrder == "size" {
		sort.Slice(tasks, func(i, j int) bool {
			return tasks[i].Size < tasks[j].Size
		})
	}
	// 'quality' sort would need ffprobe analysis here, simplified for now
	
	return tasks, err
}


func validateConfig(cfg Config) error {
	if cfg.TargetDir == "" {
		return fmt.Errorf("目标目录未指定")
	}
	if _, err := os.Stat(cfg.TargetDir); os.IsNotExist(err) {
		return fmt.Errorf("目标目录不存在: %s", cfg.TargetDir)
	}
	if cfg.Mode != "quality" && cfg.Mode != "efficiency" && cfg.Mode != "auto" {
		return fmt.Errorf("无效的模式: %s. 请选择 'quality', 'efficiency', or 'auto'", cfg.Mode)
	}
	return nil
}

func interactiveSetup(cfg *Config) {
	reader := bufio.NewReader(os.Stdin)
	
	showBanner()

	// Get target directory
	for {
		fmt.Print(bold(cyan("📂 请输入或拖入目标文件夹, 然后按 Enter: ")))
		input, _ := reader.ReadString('\n')
		input = strings.TrimSpace(input)
		// Clean path from drag-and-drop (remove quotes, etc.)
		input = strings.Trim(input, `"'`)
		if _, err := os.Stat(input); err == nil {
			cfg.TargetDir, _ = filepath.Abs(input)
			break
		}
		fmt.Println(yellow("⚠️ 无效的目录，请重新输入。"))
	}

	// Get mode
	fmt.Println("\n" + bold(cyan("⚙️ 请选择转换模式: ")))
	fmt.Printf("  %s %s - 追求极致画质，适合存档。\n", green("[1]"), bold("质量模式 (Quality)"))
	fmt.Printf("  %s %s - 平衡画质与体积，适合日常。\n", yellow("[2]"), bold("效率模式 (Efficiency)"))
	fmt.Printf("  %s %s - %s\n", violet("[3]"), bold("自动模式 (Auto)"), bold(subtle("强烈推荐!")))
	
	for {
		fmt.Print(bold(cyan("👉 请输入您的选择 (1/2/3) [回车默认 3]: ")))
		input, _ := reader.ReadString('\n')
		input = strings.TrimSpace(input)
		if input == "" || input == "3" {
			cfg.Mode = "auto"
			break
		}
		if input == "1" {
			cfg.Mode = "quality"
			break
		}
		if input == "2" {
			cfg.Mode = "efficiency"
			break
		}
	}
}

func showBanner() {
	color.Cyan(`
         __  __          __           _       ____                          __
        / / / /___ _____/ /___  _    (_)___  / __ \____ _      _____  _____/ /
       / /_/ / __ ` + "`" + `/ __  / __ \| |   / / __ \/ / / / __ \ | /| / / _ \/ ___/ / 
      / __  / /_/ / /_/ / /_/ /| |  / / /_/ / /_/ / /_/ / |/ |/ /  __/ /  /_/  
     /_/ /_/\__,_/\__,_/\____/ |___/ /\____/_____/\____/|__/|__/\___/_/  (_)   
                               /___/                                         
	`)
	fmt.Printf(bold(violet("              ✨ 欢迎使用媒体批量转换脚本 v%s ✨\n")), Version)
	fmt.Println(subtle("                  Go 语言重构版 - 稳定、高效、跨平台"))
	fmt.Println("================================================================================\n")
}

func showProgress(current, total int, taskName string) {
	if total == 0 {
		return
	}
	pct := float64(current) / float64(total) * 100
	barWidth := 40
	filledWidth := int(float64(barWidth) * float64(current) / float64(total))
	
	bar := strings.Repeat("█", filledWidth) + strings.Repeat("░", barWidth-filledWidth)
	
	fmt.Printf("\r%s [%s] %.0f%% (%d/%d)", taskName, cyan(bar), pct, current, total)
}


func generateReport(cfg Config, results []conversionResult) {
	var report strings.Builder

	report.WriteString(fmt.Sprintf("%s\n", bold(cyan("📊 ================= 媒体转换最终报告 =================="))))
	report.WriteString(fmt.Sprintf("%s %s\n", subtle("📁 目录:"), cfg.TargetDir))
	report.WriteString(fmt.Sprintf("%s %s    %s %s\n", subtle("⚙️ 模式:"), cfg.Mode, subtle("🚀 Go 版本:"), Version))
	report.WriteString(fmt.Sprintf("%s %s\n\n", subtle("⏰ 完成:"), time.Now().Format(time.RFC1123)))
	
	report.WriteString(fmt.Sprintf("%s\n", bold(cyan("--- 📋 概览 ---"))))
	report.WriteString(fmt.Sprintf("  %s 总计扫描: %d 文件\n", violet("🗂️"), totalFiles+resumedCount))
	report.WriteString(fmt.Sprintf("  %s 成功转换: %d\n", green("✅"), successCount))
	report.WriteString(fmt.Sprintf("  %s 转换失败: %d\n", red("❌"), failCount))
	report.WriteString(fmt.Sprintf("  %s 主动跳过: %d\n", subtle("⏭️"), skipCount))
	report.WriteString(fmt.Sprintf("  %s 断点续传: %d (已处理)\n\n", cyan("🔄"), resumedCount))

	report.WriteString(fmt.Sprintf("%s\n", bold(cyan("--- 💾 大小变化统计 ---"))))
	report.WriteString(fmt.Sprintf("  %s 总空间节省: %s\n\n", green("💰"), bold(green(formatBytes(totalSaved)))))

	report.WriteString(fmt.Sprintf("%s\n", bold(cyan("--- 🏅 编码质量分布 ---"))))
	qualitySummary := make(map[string]int)
	for _, res := range results {
		if res.Tag != "" {
			qualitySummary[res.Tag]++
		}
	}
	for tag, count := range qualitySummary {
		report.WriteString(fmt.Sprintf("  %s(%d) ", tag, count))
	}
	report.WriteString("\n\n")

	report.WriteString("--------------------------------------------------------\n")
	report.WriteString(fmt.Sprintf("%s %s\n", subtle("📄 详细日志:"), logFile.Name()))
	
	failedFiles := []string{}
	for _, res := range results {
		if res.Error != nil {
			failedFiles = append(failedFiles, fmt.Sprintf("  • %s (错误: %v)", filepath.Base(res.FilePath), res.Error))
		}
	}
	if len(failedFiles) > 0 {
		report.WriteString(fmt.Sprintf("\n%s\n", red(bold("❌ 失败文件列表:"))))
		report.WriteString(strings.Join(failedFiles, "\n"))
	}
	
	// Print to console and write to file
	fmt.Println("\n" + report.String())
	os.WriteFile(reportFile, []byte(report.String()), 0644)
}